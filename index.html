<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fatal Engine User Guide</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="res/img/FatalEngineLogo.png" rel="icon">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins">
    <link rel="stylesheet" href="res/css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <svg style="display: none;">
        <!-- Camera -->
        <symbol id="camera-icon" viewBox="0 0 24 24">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2v11z"/>
            <circle cx="12" cy="13" r="4"/>
        </symbol>
        <!-- Light -->
        <symbol id="bulb-icon" viewBox="0 0 24 24" fill="none" stroke-width="2">
            <path d="M9 21h6" stroke-linecap="round"/>
            <path d="M10 17h4" stroke-linecap="round"/>
            <path d="M12 3a7 7 0 0 1 7 7c0 2.2-1.1 4.2-2.8 5.4-.8.6-1.2 1.6-1.2 2.6v1H9v-1c0-1-.4-2-1.2-2.6A7.2 7.2 0 0 1 5 10a7 7 0 0 1 7-7z"/>
        </symbol>
        <!-- Window -->
        <symbol id="window-icon" fill="red">
            <path xmlns="http://www.w3.org/2000/svg" d="M40.69 0h430.62C493.69 0 512 18.31 512 40.69v348.18c0 22.37-18.31 40.68-40.69 40.68H40.69C18.31 429.55 0 411.24 0 388.87V40.69C0 18.31 18.31 0 40.69 0zm304.13 231.55c7.24 0 13.16 6.08 13.16 13.17v28.63c0 7.12-6.02 13.15-13.16 13.15H167.25c-7.15 0-13.16-5.92-13.16-13.16v-28.62c0-7.25 5.92-13.17 13.16-13.17h177.57zm130.23-104.69H38.78v253.05c0 6.25 5.02 11.26 11.27 11.26h413.57c6.25 0 11.26-5.01 11.26-11.26V126.86h.17zm-42.47-81.12c11.1 0 20.1 9 20.1 20.1 0 11.1-9 20.09-20.1 20.09-11.09 0-20.09-8.99-20.09-20.09s9-20.1 20.09-20.1zm-136.21 0c11.1 0 20.09 9 20.09 20.1 0 11.1-8.99 20.09-20.09 20.09s-20.1-8.99-20.1-20.09 9-20.1 20.1-20.1zm68.11 0c11.1 0 20.09 9 20.09 20.1 0 11.1-9 20.09-20.09 20.09-11.1 0-20.1-8.99-20.1-20.09s9-20.1 20.1-20.1z"/>
        </symbol>
        <!-- Shadow -->
        <symbol id="shadow-icon" fill="red">
            <path xmlns="http://www.w3.org/2000/svg" d="M24.07,20.52A11.49714,11.49714,0,1,0,13.38,27.5c1.2,2.36,5.24,4,10.12,4C29.49,31.5,34,29.14,34,26,34,22.96,29.77,20.65,24.07,20.52ZM4,16a9.5,9.5,0,0,1,19,0,9.35052,9.35052,0,0,1-1.43,5,9.50975,9.50975,0,0,1-7.56,4.49c-.17.01-.34.01-.51.01A9.50861,9.50861,0,0,1,4,16Z"/>
        </symbol>
        <symbol id="ecs-icon" fill="red">
            <path d="M32.1,141.15h76.7c17.7,0,32.1-14.4,32.1-32.1v-76.7c0-17.7-14.4-32.1-32.1-32.1H32.1C14.4,0.25,0,14.65,0,32.35v76.7    C0,126.75,14.4,141.15,32.1,141.15z M24.5,32.35c0-4.2,3.4-7.6,7.6-7.6h76.7c4.2,0,7.6,3.4,7.6,7.6v76.7c0,4.2-3.4,7.6-7.6,7.6    H32.1c-4.2,0-7.6-3.4-7.6-7.6V32.35z"/>
            <path d="M0,283.45c0,17.7,14.4,32.1,32.1,32.1h76.7c17.7,0,32.1-14.4,32.1-32.1v-76.7c0-17.7-14.4-32.1-32.1-32.1H32.1    c-17.7,0-32.1,14.4-32.1,32.1V283.45z M24.5,206.65c0-4.2,3.4-7.6,7.6-7.6h76.7c4.2,0,7.6,3.4,7.6,7.6v76.7c0,4.2-3.4,7.6-7.6,7.6    H32.1c-4.2,0-7.6-3.4-7.6-7.6V206.65z"/>
            <path d="M0,457.75c0,17.7,14.4,32.1,32.1,32.1h76.7c17.7,0,32.1-14.4,32.1-32.1v-76.7c0-17.7-14.4-32.1-32.1-32.1H32.1    c-17.7,0-32.1,14.4-32.1,32.1V457.75z M24.5,381.05c0-4.2,3.4-7.6,7.6-7.6h76.7c4.2,0,7.6,3.4,7.6,7.6v76.7c0,4.2-3.4,7.6-7.6,7.6    H32.1c-4.2,0-7.6-3.4-7.6-7.6V381.05z"/>
            <path d="M477.8,31.75H202.3c-6.8,0-12.3,5.5-12.3,12.3c0,6.8,5.5,12.3,12.3,12.3h275.5c6.8,0,12.3-5.5,12.3-12.3    C490.1,37.25,484.6,31.75,477.8,31.75z"/>
            <path d="M477.8,85.15H202.3c-6.8,0-12.3,5.5-12.3,12.3s5.5,12.3,12.3,12.3h275.5c6.8,0,12.3-5.5,12.3-12.3    C490,90.65,484.6,85.15,477.8,85.15z"/>
            <path d="M477.8,206.05H202.3c-6.8,0-12.3,5.5-12.3,12.3s5.5,12.3,12.3,12.3h275.5c6.8,0,12.3-5.5,12.3-12.3    C490,211.55,484.6,206.05,477.8,206.05z"/>
            <path d="M477.8,259.55H202.3c-6.8,0-12.3,5.5-12.3,12.3s5.5,12.3,12.3,12.3h275.5c6.8,0,12.3-5.5,12.3-12.3    C490,265.05,484.6,259.55,477.8,259.55z"/>
            <path d="M477.8,380.45H202.3c-6.8,0-12.3,5.5-12.3,12.3s5.5,12.3,12.3,12.3h275.5c6.8,0,12.3-5.5,12.3-12.3    C490,385.95,484.6,380.45,477.8,380.45z"/>
            <path d="M490,446.15c0-6.8-5.5-12.3-12.3-12.3H202.3c-6.8,0-12.3,5.5-12.3,12.3s5.5,12.3,12.3,12.3h275.5    C484.6,458.35,490,452.85,490,446.15z"/>
        </symbol>
        <symbol id="input-icon" fill="red">
            <style type="text/css">
                .st0{fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;}
                .st1{fill:none;stroke-width:2;stroke-linejoin:round;stroke-miterlimit:10;}
            </style>
            <path class="st0" d="M16,29L16,29c-5,0-9-4-9-9V9c0-3.3,2.7-6,6-6h6c3.3,0,6,2.7,6,6v11C25,25,21,29,16,29z"/>
            <line class="st0" x1="16" y1="3" x2="16" y2="8"/>
            <path class="st0" d="M16,15L16,15c-1.1,0-2-0.9-2-2v-3c0-1.1,0.9-2,2-2h0c1.1,0,2,0.9,2,2v3C18,14.1,17.1,15,16,15z"/>
        </symbol>
    </svg>
</head>
<body>
    <!-- Sidebar/menu -->
    <nav class="sidebar red collapse w3-top w3-large w3-padding" style="z-index:3;width:300px;font-weight:bold;" id="mySidebar"><br>
    <a href="javascript:void(0)" onclick="w3_close()" class="w3-button w3-hide-large w3-display-topleft" style="width:100%;font-size:22px">Close Menu</a>
    <div class="w3-container">
        <img src="res/img/FatalEngineLogo.png" alt="Fatal Engine Logo" class="sidebar-logo">
        <h3 class="w3-padding-64"><b>Fatal Engine</b></h3>
    </div>
    <div class="w3-bar-block">
        <a href="#" onclick="close()" class="w3-bar-item w3-button w3-hover-white">Home</a> 
        <a href="#Dependencies" onclick="close()" class="w3-bar-item w3-button w3-hover-white">Dependencies</a> 
        <a href="#SetUp" onclick="close()" class="w3-bar-item w3-button w3-hover-white">Set up</a> 
        <a href="#Examples" onclick="close()" class="w3-bar-item w3-button w3-hover-white">Examples</a>
        <a href="#Documentation" onclick="close()" class="w3-bar-item w3-button w3-hover-white">Documentation</a>
    </div>
    </nav>

    <!-- Top menu on small screens -->
    <header class="w3-container w3-top w3-hide-large w3-red w3-xlarge w3-padding">
        <a href="javascript:void(0)" class="w3-button w3-red w3-margin-right" onclick="open()">☰</a>
        <span>Fatal Engine</span>
    </header>

    <!-- Overlay effect when opening sidebar on small screens -->
    <div class="w3-overlay w3-hide-large" onclick="close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

    <!-- !PAGE CONTENT! -->
    <div class="w3-main" style="margin-left:340px;margin-right:40px">

    <!-- Version Header -->
    <div class="w3-container" style="margin-top:5px;" align="end">
        <h2><b>v0.01</b></h1>
    </div>
    
    <!-- Header -->
    <div class="w3-container" style="margin-top:30px" id="showcase">
        <h1 class="w3-jumbo"><b>Fatal Engine</b></h1>
    </div>
        
    <!-- Dependencies -->
    <div class="w3-container" id="Dependencies" style="margin-top:25px">
        <h1 class="w3-xxxlarge w3-text-red"><b>Dependencies</b></h1>
        <hr style="width:50px;border:5px solid red" class="w3-round">
        <p>For the correct use of the Fatal Engine you will need to install the following dependencies and tools:</p>
        <ul>
            <li><a href="https://www.python.org/downloads/" title="Python 3.11">Python</a></li>
            <li><a href="https://conan.io/downloads" title="Conan C/C++ Package Manager">Conan</a></li>
            <li><a href="https://cmake.org/" title="CMake">CMake</a></li>
            <li><a href="https://visualstudio.microsoft.com/es/vs/" title="Visual Studio 2022 Community Version">Visual Studio 2022</a></li>
            <li><a href="https://premake.github.io/download" title="Premake 5">Premake</a></li>
        </ul>
    </div>
    
    <!-- Set Up -->
    <div class="w3-container" id="SetUp" style="margin-top:25px">
        <h1 class="w3-xxxlarge w3-text-red"><b>Set Up</b></h1>
        <hr style="width:50px;border:5px solid red" class="w3-round">
        <p>For a correct installation, you need to follow this instructions:</p>
        <code style="font-size: 15px;">
            <ol>
                <li>Download the last version of the engine from the official <a href="" target="_blank" title="Fatal Engine">Fatal Engine Github repository</a>.</li>
                <li>Unzip the package.</li>
                <li>Open the <b><i>CMD</i></b> or the <b><i>Developer Command Prompt for VS</i></b> and go to the following route: "<code style="background-color: rgb(56, 56, 56); border-radius: 3px; color: white;">tools\</code>".</li>
                <li>Execute the file called "<code style="background-color: rgb(56, 56, 56); border-radius: 3px; color: white;">gendeps.bat</code>", once the proccess finishes you will see "<code style="background-color: rgb(56, 56, 56); border-radius: 3px; color: white;">build\</code>" on the main folder of the project.</li>
                <li>Enter the "<code style="background-color: rgb(56, 56, 56); border-radius: 3px; color: white;">build\</code>" directory and open "<code style="background-color: rgb(56, 56, 56); border-radius: 3px; color: white;">FatalEngine.sln</code>" to use the engine.</li>
            </ol>
        </code>
    </div>
    
    <!-- Example -->
    <div class="w3-container" id="Examples" style="margin-top:25px">
        <h1 class="w3-xxxlarge w3-text-red"><b>Examples</b></h1>
        <hr style="width:50px;border:5px solid red" class="w3-round">

        <!-- Window -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('Window')" class="w3-light-grey collapsible">
                <svg class="architecture-icon" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 429.55">
                    <use href="#window-icon"></use>
                </svg>
                <b class="icon-title">Window</b> <span class="toggle-icon" id="icon-example1">+</span>
            </button>
            <div id="Window" class="w3-container w3-hide">
                <p>El ejemplo que vamos a enseñarte es como podrias abrir una ventana desde cero con FatalEngine, con que includes de motor necesites y como estructurarlo:</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
                    
#include "window.hpp" //include para la ventana

int WinMain()
{
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    const int kWidthWindow = 600;
    const int kHeightWindow = 600;

    bool* changeIntervalue = (bool)malloc(sizeof(bool) 4);

    RMPH::WindowSystem PD; // sistema para crear ventana
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"ShadowMap",&PD }; // crear ventana

    while (screen.IsOpen()) // bucle de vida de la scene, mas compropante de si la ventana esta abierta
    {

        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        screen.SwapBuffer();
        glfwPollEvents();
    }

    screen.~Window(); // destructures de la scena
    PD.~WindowSystem(); //destructor del sistema de scena

    return 0;
}
                </code></pre>
            </div>
        </div>
        
        <!-- Camera -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('Camera')" class="w3-light-grey collapsible">
                <svg class="architecture-icon">
                    <use href="#camera-icon"></use>
                </svg>
                <b class="icon-title">Camera</b> <span class="toggle-icon" id="icon-example1">+</span>
            </button>
            <div id="Camera" class="w3-container w3-hide">
                <p>Para poder ver el mundo de juego necesitas varios componenetes como el ECS,Camera,Light y Input para poder crear una escena propia, ahora tye enseñanemos la camara pero puedes ir progresando en todos a la evss con los ejemplos proporcionados.</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
                    
#include "Camera.hpp" 
#include "Input.hpp" 
#include "window.hpp" 
#include "esc.hpp" 
#include "Components.hpp"
#include "Sistems.hpp"
#include "tools.hpp"
                    
const int kWidthWindow = 800;
const int kHeightWindow = 800;
                    
float kLastX = kWidthWindow / 2.0f;
float kLastY = kHeightWindow / 2.0f;
bool kFirstMouse = true;
                    
int WinMain() {
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;
                    
    bool* changeIntervalue = (bool*)malloc(sizeof(bool) * 4);
                    
    RMPH::WindowSystem PD; // sistema para crear ventana
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"ShadowMap",&PD }; // crear ventana
                    
    RMPH::Input inputManager{ &screen,&PD }; //gestionador de inputs
                    
    RMPH::ECSManager Manager; // gestionador de entidades
                    
    size_t cam = Manager.create_entity(); // crear entidad de camara
                    
    Manager.add_component_type&lt;RMPH::TranformComponent&gt;(); // indicar los componentes que vas a usar 
    Manager.add_component_type&lt;RMPH::CameraComponent&gt;(); // indicar los componentes que vas a usar 
                    
    RMPH::TranformComponent  avgCam;
                    
    //CAMERA
                    
    avgCam.transform3D = RMPH::Transform3D(glm::vec3(0, 10, -5), glm::vec3(1, 1, 1), glm::vec3(45, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(cam) = avgCam; // añadir un Component Transform a la camara
                    
    RMPH::CameraComponent avgC;
                    
    avgC.cam_ = std::make_shared&lt;RMPH::Camera&gt;(0.001f, 45.0f, 10.0f, 1, RMPH::Camera::View::Perspectiva); 
                    
    Manager.get_component&lt;RMPH::CameraComponent&gt;(cam) = avgC; // añadir un Component Camera a la camara
                    
    while (screen.IsOpen()) {
                    
        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
                    
        //ejemplo de como mover la camara
                    
    /*  if (inputManager.IsKeyPressed(RMPH::Input::MOUSE_LEFT)) {
                    
            float xoffset = inputManager.MouseX() - kLastX;
            float yoffset = kLastY - inputManager.MouseY();
                    
            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();
                    
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(yoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, xoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, 0));
        } else {
            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();
        }
                    
        if (inputManager.IsKeyPressed(RMPH::Input::UP)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
                    
        if (inputManager.IsKeyPressed(RMPH::Input::DOWN)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::LEFT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::RIGHT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::Q)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::E)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
                    
        if (inputManager.IsKeyPressed(RMPH::Input::D)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, -Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::A)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::W)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(-Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::S)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }*/
                    
        screen.SwapBuffer();
        glfwPollEvents();
    }
                    
    screen.~Window();
    PD.~WindowSystem();
    inputManager.~Input();
                    
    return 0;
}
                </code></pre>
            </div>
        </div>

        <!-- ECS Scene -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('ECS')" class="w3-light-grey collapsible">
                <svg class="architecture-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="red" height="800px" width="800px" version="1.1" id="Capa_1" viewBox="0 0 490.1 490.1" xml:space="preserve">
                    <use href="#ecs-icon"></use>
                </svg>
                <b class="icon-title">ECS</b> <span class="toggle-icon" id="icon-example2">+</span>
            </button>
            <div id="ECS" class="w3-container w3-hide">
                <p>El ECS es la parte crucial de una escena para que funcione y es crucial manejarlo bien, por ende el ejemplo esta con su uso completo, pero fragmentado para que puedes reducir su escala.</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
#include "Shader.hpp" //
#include "Camera.hpp" //
#include "Model.hpp" //
#include "Input.hpp" //
#include "window.hpp" //
#include "esc.hpp" //
#include "Components.hpp"//
#include "Sistems.hpp"//
#include "tools.hpp"//


const int kWidthWindow = 800;
const int kHeightWindow = 800;

float kLastX = kWidthWindow / 2.0f;
float kLastY = kHeightWindow / 2.0f;
bool kFirstMouse = true;

void JiggleMove(std::vector&lt;std::optional&lt;RMPH::TranformComponent&gt;&gt;& posinfo, std::vector&lt;std::optional&lt;RMPH::RenderComponent&gt;&gt;& render, bool* change, float interlapse) {
    for (int i = 0; i &lt; posinfo.size(); i++) {
        if (nullopt != render[i]) {
            if (change[i]) {
                if (posinfo[i]-&gt;transform3D.GetPosition().z &gt; interlapse) {
                    change[i] = false;
                }
                posinfo[i]-&gt;transform3D.Translate(glm::vec3(0.0f, 0.0f, 0.01f));
            }
            else {
                if (posinfo[i]-&gt;transform3D.GetPosition().z &lt; -interlapse) {
                    change[i] = true;
                }
                posinfo[i]-&gt;transform3D.Translate(glm::vec3(0.0f, 0.0f, -0.01f));
            }
        }
    }
}


int WinMain()
{
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    bool* changeIntervalue = (bool*)malloc(sizeof(bool) * 4);

    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);


    RMPH::WindowSystem PD;
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"ECS",&PD };

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
        return -1;
    }

    RMPH::Input inputManager{ &screen,&PD };

    glEnable(GL_DEPTH_TEST);

    RMPH::Shader ourShader("../deps/shaders/vertexObjLight.vs", "../deps/shaders/fragmentObjLight.fs"); //Shader para luces sin sombra

    //Declarar ECS
    
    RMPH::ECSManager Manager;

    RMPH::RenderComponent  avgProto;

    //Crear entidadtes 

    size_t avgdemo = Manager.create_entity();
    size_t avgdemo2 = Manager.create_entity();
    size_t avgdemo3 = Manager.create_entity();
    size_t avgdemo4 = Manager.create_entity();
    size_t avgdemo5 = Manager.create_entity();
    size_t light = Manager.create_entity();
    size_t cam = Manager.create_entity();

    //Componentes que puede llevar las entidades, si les coloca a nulo de base

    Manager.add_component_type&lt;RMPH::RenderComponent&gt;();
    Manager.add_component_type&lt;RMPH::TranformComponent&gt;();
    Manager.add_component_type&lt;RMPH::LightComponent&gt;(); 
    Manager.add_component_type&lt;RMPH::CameraComponent&gt;();

    //Editor de material y obj

    avgProto.model_ = std::make_shared&lt;RMPH::Model&gt;("../deps/obj/cube.obj");
    avgProto.matirial_.Ambient = glm::vec3(0.329412f, 0.223529f, 0.027451f);
    avgProto.matirial_.Diffuse = glm::vec3(0.780392f, 0.568627f, 0.113725f);
    avgProto.matirial_.Specular = glm::vec3(0.992157f, 0.941176f, 0.807843f);
    avgProto.matirial_.Shininess = 32.0f;

    SetTexture(avgProto, "../texture/cube.jpg"); //Asisganar texture

    //AsisgnaciÃ³n de rendere

    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2) = avgProto;
    // Manager.get_component&lt;RMPH::RenderComponent&gt;(light) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4) = avgProto;

    RMPH::TranformComponent  avg5, avg6, avg7, avg8, avg9, avg10, avgCam, avgLgh, avgLgh2, avgLgh3, avgLgh4, avgLgh5;

    //CUBE

    avg6.transform3D.Translate(glm::vec3(0, 0, 0));
    avg6.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg6.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo) = avg6;

    avg5.transform3D.Translate(glm::vec3(2, 0, 0));
    avg5.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg5.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo2) = avg5;

    avg8.transform3D.Translate(glm::vec3(-2, 0, 0));
    avg8.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg8.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo3) = avg8;

    avg9.transform3D.Translate(glm::vec3(0, 2, 0));
    avg9.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg9.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo4) = avg9;

    avg10.transform3D.Translate(glm::vec3(0, -2, 0));
    avg10.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg10.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo5) = avg10;

    //CAMERA

    avgCam.transform3D.Translate(glm::vec3(0, 5, -3));
    avgCam.transform3D.Scale(glm::vec3(1, 1, 1));
    avgCam.transform3D.Rotate(glm::vec3(45, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(cam) = avgCam;

    //LIGHT

    avgLgh.transform3D.Translate(glm::vec3(0, 0, 0));
    avgLgh.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light) = avgLgh; //ambient


    //Camara

    RMPH::CameraComponent avgC;

    avgC.cam_ = std::make_shared&lt;RMPH::Camera&gt;(0.1f, 45.0f, 10, 0.01f, RMPH::Camera::View::Perspectiva);

    Manager.get_component&lt;RMPH::CameraComponent&gt;(cam) = avgC;

    RMPH::LightComponent avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(1, 1, 1);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLight.Direction = glm::vec3(0, -1, 0);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::Ambient;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light) = avgLight;

    while (screen.IsOpen())
    {

        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        JiggleMove(Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), changeIntervalue, 2.5f); //Sistema para mover objetos

        RMPH::RenderingNoShadow(Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), ourShader,
            Manager.get_component_list&lt;RMPH::LightComponent&gt;(), Manager.get_component&lt;RMPH::CameraComponent&gt;(cam), Manager.get_component&lt;RMPH::TranformComponent&gt;(cam), kWidthWindow, kHeightWindow); //Render de luz sin sombra

        screen.SwapBuffer();
        glfwPollEvents();
    }

    screen.~Window();
    PD.~WindowSystem();
    inputManager.~Input();

    return 0;
}
                    
                </code></pre>
            </div>
        </div>

        <!-- Input -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('Input')" class="w3-light-grey collapsible">
                <svg class="architecture-icon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Icons" viewBox="0 0 32 32" xml:space="preserve">
                    <use href="#input-icon"></use>
                </svg>
                <b class="icon-title">Input</b> <span class="toggle-icon" id="icon-example1">+</span>
            </button>
            <div id="Input" class="w3-container w3-hide">
                <p>El input demostrado es para manejar la camara en un estilo Unity o de motores similares, pero se puede usar para manejar cualquier cosa.</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
                    
#include "Shader.hpp" 
#include "Camera.hpp" 
#include "Model.hpp" 
#include "Input.hpp" //Su Liberia
#include "window.hpp" 
#include "esc.hpp" 
#include "Components.hpp"
#include "Sistems.hpp"
#include "tools.hpp"

const int kWidthWindow = 800;
const int kHeightWindow = 800;

float kLastX = kWidthWindow / 2.0f;
float kLastY = kHeightWindow / 2.0f;
bool kFirstMouse = true;

int WinMain()
{
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    bool* changeIntervalue = (bool*)malloc(sizeof(bool) * 4);

    RMPH::WindowSystem PD;
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"InputTest",&PD };

    RMPH::StartGlad(); // Para inicial el glad para 3D

    //Crear el manager del input

    RMPH::Input inputManager{ &screen,&PD };

    RMPH::Shader ourShaderShadow("../deps/shaders/vertexShadow.vs", "../deps/shaders/fragmentShadow.fs", nullptr);

    RMPH::ECSManager Manager;

    RMPH::RenderComponent avg, avgProto;

    size_t avgdemo = Manager.create_entity();
    size_t avgdemo2 = Manager.create_entity();
    size_t avgdemo3 = Manager.create_entity();
    size_t avgdemo4 = Manager.create_entity();
    size_t avgdemo5 = Manager.create_entity();
    size_t lightD = Manager.create_entity();
    size_t lightA = Manager.create_entity();
    size_t lightSNSE = Manager.create_entity();
    size_t lightSSE = Manager.create_entity();
    size_t lightP = Manager.create_entity();

    size_t cam = Manager.create_entity();

    Manager.add_component_type&lt;RMPH::RenderComponent&gt;();
    Manager.add_component_type&lt;RMPH::TranformComponent&gt;();
    Manager.add_component_type&lt;RMPH::LightComponent&gt;();
    Manager.add_component_type&lt;RMPH::CameraComponent&gt;();

    avgProto.model_ = std::make_shared&lt;RMPH::Model&gt;("../deps/obj/cube.obj");
    avgProto.matirial_.Ambient = glm::vec3(0.329412f, 0.223529f, 0.027451f);
    avgProto.matirial_.Diffuse = glm::vec3(0.780392f, 0.568627f, 0.113725f);
    avgProto.matirial_.Specular = glm::vec3(0.992157f, 0.941176f, 0.807843f);
    avgProto.matirial_.Shininess = 0.21794872f * 128.0f;

    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4) = avgProto;

    //stbi_set_flip_vertically_on_load(true);

    RMPH::TranformComponent  avg5, avg6, avg7, avg8, avg9, avg10, avgCam, avgLgh, avgLgh2, avgLgh3, avgLgh4, avgLgh5;

    //CUBE
    avg6.transform3D = RMPH::Transform3D(glm::vec3(2, 0, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo) = avg6;

    avg5.transform3D = RMPH::Transform3D(glm::vec3(-2, 0, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo2) = avg5;

    avg8.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo3) = avg8;

    avg9.transform3D = RMPH::Transform3D(glm::vec3(0, 2, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo4) = avg9;

    avg10.transform3D = RMPH::Transform3D(glm::vec3(0, -2, 0), glm::vec3(9, 0.5f, 9), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo5) = avg10;

    //CAMERA

    avgCam.transform3D = RMPH::Transform3D(glm::vec3(0, 10, -5), glm::vec3(1, 1, 1), glm::vec3(45, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(cam) = avgCam;

    //LIGHT

    avgLgh.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightA) = avgLgh; //ambient

    avgLgh2.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightD) = avgLgh2; //directional

    avgLgh4.transform3D = RMPH::Transform3D(glm::vec3(2, 2, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightSNSE) = avgLgh4; //spot NS

    avgLgh5.transform3D = RMPH::Transform3D(glm::vec3(-2, 2, 0), glm::vec3(0.2f, 0.2f, 0.2f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightSSE) = avgLgh5; //spot s

    avgLgh5.transform3D = RMPH::Transform3D(glm::vec3(0, 1.5f, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightP) = avgLgh3; //point

    RMPH::CameraComponent avgC;

    avgC.cam_ = std::make_shared&lt;RMPH::Camera&gt;(0.1f, 45.0f, 10.0f, 1, RMPH::Camera::View::Perspectiva);

    Manager.get_component&lt;RMPH::CameraComponent&gt;(cam) = avgC;

    RMPH::LightComponent avgLightD, avgLightA, avgLightSNSE, avgLightSSE, avgLightP;

    RMPH::Shader DepthCreater("../deps/shaders/vertexDepthMap.vs", "../deps/shaders/fragmentDepthMap.fs", nullptr);

    avgLightD.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightD.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightD.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightD.Specular = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightD.Direction = glm::vec3(1, 1, 1);
    avgLightD.Constant = 1.0f;
    avgLightD.Linear = 0.09f;
    avgLightD.Quadratic = 0.032f;
    avgLightD.CutOff = glm::cos(glm::radians(12.5f));
    avgLightD.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightD.type = RMPH::Directional;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightD) = avgLightD;

    avgLightA.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightA.Ambient = glm::vec3(0.3, 0.3, 0.3);
    avgLightA.type = RMPH::Ambient;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightA) = avgLightA;

    avgLightSNSE.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightSNSE.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightSNSE.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightSNSE.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLightSNSE.Direction = glm::vec3(0, -1, 0);
    avgLightSNSE.Constant = 1.0f;
    avgLightSNSE.Linear = 0.09f;
    avgLightSNSE.Quadratic = 0.032f;
    avgLightSNSE.CutOff = glm::cos(glm::radians(12.5f));
    avgLightSNSE.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightSNSE.type = RMPH::SpotNoSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightSNSE) = avgLightSNSE;

    avgLightSSE.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightSSE.Ambient = glm::vec3(0.6f, 0.6f, 0.2f);
    avgLightSSE.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightSSE.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLightSSE.Direction = glm::vec3(0, -1, 0);
    avgLightSSE.Constant = 1.0f;
    avgLightSSE.Linear = 0.09f;
    avgLightSSE.Quadratic = 0.032f;
    avgLightSSE.CutOff = glm::cos(glm::radians(12.5f));
    avgLightSSE.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightSSE.type = RMPH::SpotSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightSSE) = avgLightSSE;

    avgLightP.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightP.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightP.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightP.Specular = glm::vec3(0, 0, 0);
    avgLightP.Direction = glm::vec3(1, 0, 0);
    avgLightP.Constant = 1.0f;
    avgLightP.Linear = 0.09f;
    avgLightP.Quadratic = 0.032f;
    avgLightP.CutOff = glm::cos(glm::radians(12.5f));
    avgLightP.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightP.type = RMPH::Point;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightP) = avgLightP;

    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5).value(), "../texture/cube.jpg");

    // configure depth map FBO
       // -----------------------
    const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;
    unsigned int depthMapFBO;
    // create depth texture
    unsigned int depthMap;
    
    RMPH::CreateDepthBuffer(depthMapFBO, depthMap, SHADOW_WIDTH, SHADOW_HEIGHT);

    //IMPORTANTE SOLO HAY SOMBRA DIRRECIONAL DE MOMENTO

    while (screen.IsOpen())
    {

        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        if (inputManager.IsKeyPressed(RMPH::Input::MOUSE_LEFT)) { //Ejemplo de uso de input para manejar la camara con el raton

            float xoffset = inputManager.MouseX() - kLastX;
            float yoffset = kLastY - inputManager.MouseY();

            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();

            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(yoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, xoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, 0));
        }
        else {
            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();
        }

        //Ejemplo de input para manejar la camara con botones del teclado

        if (inputManager.IsKeyPressed(RMPH::Input::UP)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }

        if (inputManager.IsKeyPressed(RMPH::Input::DOWN)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::LEFT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::RIGHT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::Q)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::E)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }

        if (inputManager.IsKeyPressed(RMPH::Input::D)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, -Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::A)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::W)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(-Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::S)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }

        //Render diferente para las sombras

        RenderingShadow(Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), Manager.get_component_list&lt;RMPH::TranformComponent&gt;(),
            ourShaderShadow, Manager.get_component_list&lt;RMPH::LightComponent&gt;(), Manager.get_component&lt;RMPH::CameraComponent&gt;(cam),
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam),depthMapFBO,depthMap,DepthCreater,kWidthWindow,kHeightWindow);

        screen.SwapBuffer();
        glfwPollEvents();
    }

    screen.~Window();
    PD.~WindowSystem();
    inputManager.~Input();

    return 0;
}
                </code></pre>
            </div>
        </div>

        <!-- Light -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('Light')" class="w3-light-grey collapsible">
                <svg class="architecture-icon">
                    <use href="#bulb-icon"></use>
                </svg>
                <b class="icon-title">Light</b> <span class="toggle-icon" id="icon-example1">+</span>
            </button>
            <div id="Light" class="w3-container w3-hide">
                <p>La Light es necesaria para ver cualquier cosa en el ecenario, en el motor estan dados los shader, que con los cuales podrias hacer una escenaa con varias luces y sombras mas adelante en los ejmplo.</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
#include "Shader.hpp" //
#include "Camera.hpp" //
#include "Model.hpp" //
#include "Input.hpp" //
#include "window.hpp" //
#include "esc.hpp" //
#include "Components.hpp"//
#include "Sistems.hpp"//
#include "tools.hpp"//


const int kWidthWindow = 800;
const int kHeightWindow = 800;

float kLastX = kWidthWindow / 2.0f;
float kLastY = kHeightWindow / 2.0f;
bool kFirstMouse = true;

void JiggleMove(std::vector&lt;std::optional&lt;RMPH::TranformComponent&gt;&gt;& posinfo, std::vector&lt;std::optional&lt;RMPH::RenderComponent&gt;&gt;& render, bool* change, float interlapse) {
    for (int i = 0; i &lt; posinfo.size(); i++) {
        if (nullopt != render[i]) {
            if (change[i]) {
                if (posinfo[i]-&gt;transform3D.GetPosition().z &gt; interlapse) {
                    change[i] = false;
                }
                posinfo[i]-&gt;transform3D.Translate(glm::vec3(0.0f, 0.0f, 0.01f));
            }
            else {
                if (posinfo[i]-&gt;transform3D.GetPosition().z &lt; -interlapse) {
                    change[i] = true;
                }
                posinfo[i]-&gt;transform3D.Translate(glm::vec3(0.0f, 0.0f, -0.01f));
            }
        }
    }
}


int WinMain()
{
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    bool* changeIntervalue = (bool*)malloc(sizeof(bool) * 4);

    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);


    RMPH::WindowSystem PD;
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"Light",&PD };

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
        return -1;
    }

    RMPH::Input inputManager{ &screen,&PD };

    glEnable(GL_DEPTH_TEST);

    RMPH::Shader ourShader("../deps/shaders/vertexObjLight.vs", "../deps/shaders/fragmentObjLight.fs"); //Shader para luces sin sombra

    RMPH::ECSManager Manager;

    RMPH::RenderComponent avg, avgProto;

    size_t avgdemo = Manager.create_entity();
    size_t avgdemo2 = Manager.create_entity();
    size_t avgdemo3 = Manager.create_entity();
    size_t avgdemo4 = Manager.create_entity();
    size_t avgdemo5 = Manager.create_entity();
    size_t light = Manager.create_entity();
    size_t light2 = Manager.create_entity();
    size_t light3 = Manager.create_entity();
    size_t light4 = Manager.create_entity();
    size_t light5 = Manager.create_entity();
    size_t cam = Manager.create_entity();

    Manager.add_component_type&lt;RMPH::RenderComponent&gt;();
    Manager.add_component_type&lt;RMPH::TranformComponent&gt;();
    Manager.add_component_type&lt;RMPH::LightComponent&gt;(); //Componente de luz
    Manager.add_component_type&lt;RMPH::CameraComponent&gt;();

    avgProto.model_ = std::make_shared&lt;RMPH::Model&gt;("../deps/obj/cube.obj");
    avgProto.matirial_.Ambient = glm::vec3(0.329412f, 0.223529f, 0.027451f);
    avgProto.matirial_.Diffuse = glm::vec3(0.780392f, 0.568627f, 0.113725f);
    avgProto.matirial_.Specular = glm::vec3(0.992157f, 0.941176f, 0.807843f);
    avgProto.matirial_.Shininess = 32.0f;

    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2) = avgProto;
    // Manager.get_component&lt;RMPH::RenderComponent&gt;(light) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4) = avgProto;

    RMPH::TranformComponent  avg5, avg6, avg7, avg8, avg9, avg10, avgCam, avgLgh, avgLgh2, avgLgh3, avgLgh4, avgLgh5;

    //CUBE

    avg6.transform3D.Translate(glm::vec3(0, 0, 0));
    avg6.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg6.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo) = avg6;

    avg5.transform3D.Translate(glm::vec3(2, 0, 0));
    avg5.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg5.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo2) = avg5;

    avg8.transform3D.Translate(glm::vec3(-2, 0, 0));
    avg8.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg8.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo3) = avg8;

    avg9.transform3D.Translate(glm::vec3(0, 2, 0));
    avg9.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg9.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo4) = avg9;

    avg10.transform3D.Translate(glm::vec3(0, -2, 0));
    avg10.transform3D.Scale(glm::vec3(0.5f, 0.5f, 0.5f));
    avg10.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo5) = avg10;

    //CAMERA

    avgCam.transform3D.Translate(glm::vec3(0, 5, -3));
    avgCam.transform3D.Scale(glm::vec3(1, 1, 1));
    avgCam.transform3D.Rotate(glm::vec3(45, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(cam) = avgCam;

    //LIGHT

    avgLgh.transform3D.Translate(glm::vec3(0, 0, 0));
    avgLgh.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light) = avgLgh; //ambient

    avgLgh2.transform3D.Translate(glm::vec3(0, 0, 0));
    avgLgh2.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh2.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light2) = avgLgh2; //directional

    avgLgh3.transform3D.Translate(glm::vec3(0, 1, 0));
    avgLgh3.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh3.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light3) = avgLgh3; //point

    avgLgh4.transform3D.Translate(glm::vec3(2, 2, 0));
    avgLgh4.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh4.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light4) = avgLgh4; //spot NS

    avgLgh5.transform3D.Translate(glm::vec3(-2, 2, 0));
    avgLgh5.transform3D.Scale(glm::vec3(1, 1, 1));
    avgLgh5.transform3D.Rotate(glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(light5) = avgLgh5; //spot s

    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo).value(), "../texture/cube.jpg");

    RMPH::CameraComponent avgC;

    avgC.cam_ = std::make_shared&lt;RMPH::Camera&gt;(0.1f, 45.0f, 10,0.01f,RMPH::Camera::View::Perspectiva);

    Manager.get_component&lt;RMPH::CameraComponent&gt;(cam) = avgC;

    RMPH::LightComponent avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLight.Direction = glm::vec3(0, -1, 0);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::SpotNoSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light4) = avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(0.1, 0.1, 0.1);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLight.Direction = glm::vec3(0, -1, 0);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::Ambient;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light) = avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(0.6f, 0.6f, 0.2f);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLight.Direction = glm::vec3(0, -1, 0);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::SpotSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light5) = avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(0, 0, 0);
    avgLight.Direction = glm::vec3(1, 0, 0);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::Point;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light3) = avgLight;

    avgLight.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLight.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLight.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLight.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLight.Direction = glm::vec3(-1.0f, 0.0f, 0.0f);
    avgLight.Constant = 1.0f;
    avgLight.Linear = 0.09f;
    avgLight.Quadratic = 0.032f;
    avgLight.CutOff = glm::cos(glm::radians(12.5f));
    avgLight.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLight.type = RMPH::Directional;

    Manager.get_component&lt;RMPH::LightComponent&gt;(light2) = avgLight;

    while (screen.IsOpen())
    {

        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        JiggleMove(Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), changeIntervalue, 2.5f); //Sistema para mover objetos

        RMPH::RenderingNoShadow(Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), ourShader,
            Manager.get_component_list&lt;RMPH::LightComponent&gt;(),Manager.get_component&lt;RMPH::CameraComponent&gt;(cam), Manager.get_component&lt;RMPH::TranformComponent&gt;(cam), kWidthWindow, kHeightWindow); //Render de luz sin sombra

        screen.SwapBuffer();
        glfwPollEvents();
    }

    screen.~Window();
    PD.~WindowSystem();
    inputManager.~Input();

    return 0;
}
                </code></pre>
            </div>
        </div>

        <!-- Shadow -->
        <div class="w3-card w3-margin-bottom">
            <button onclick="toggleRow('Shadow')" class="w3-light-grey collapsible">
                <svg class="architecture-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 33 42" x="0px" y="0px">
                    <use href="#shadow-icon"></use>
                </svg>
                <b class="icon-title">Shadow</b> <span class="toggle-icon" id="icon-example1">+</span>
            </button>
            <div id="Shadow" class="w3-container w3-hide">
                <p>El ejemplo de shadow es recomendable primero ver la luz y es crucial la compresión del ECS, en este ejemplo veras todas las luces que puedes usar.</p>
                <pre><code class="language-cpp" style="border-radius: 10px;">
#include &lt;glad/glad.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;iostream&gt;
                    
#include "Shader.hpp" 
#include "Camera.hpp" 
#include "Model.hpp" 
#include "Input.hpp" 
#include "window.hpp" 
#include "esc.hpp" 
#include "Components.hpp"
#include "Sistems.hpp"
#include "tools.hpp"

const int kWidthWindow = 800;
const int kHeightWindow = 800;

float kLastX = kWidthWindow / 2.0f;
float kLastY = kHeightWindow / 2.0f;
bool kFirstMouse = true;

void RenderingPointShadow(std::vector&lt;std::optional&lt;RMPH::RenderComponent&gt;&gt;& renderconp, std::vector&lt;std::optional&lt;RMPH::TranformComponent&gt;&gt;& posinfo,
    RMPH::Shader& shader, std::vector&lt;std::optional&lt;RMPH::LightComponent&gt;&gt;& lightinfo, std::optional&lt;RMPH::CameraComponent&gt;& cam,
    std::optional&lt;RMPH::TranformComponent&gt;& camTr, unsigned int& depthMapFBO, unsigned int& depthMap, RMPH::Shader& shaderDepth,
    float widthScreen, float heightScreen) {

    glEnable(GL_BLEND);
    glDepthFunc(GL_LEQUAL);

    shader.setInt("texture_diffuse1", 0);
    shader.setInt("depthMap", 2);

    glm::mat4 lightProjection, lightView;
    glm::mat4 lightSpaceMatrix;
    float near_plane = 1.0f, far_plane = 7.5f;
    lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane);

    for (int j = 0; j &lt; lightinfo.size(); j++) {
        if (nullopt != lightinfo[j] && lightinfo[j]-&gt;type == RMPH::Point) {

            float near_plane = 1.0f;
            float far_plane = 25.0f;
            glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f),1.0f, near_plane, far_plane);
            std::vector&lt;glm::mat4&gt; shadowTransforms;
            glm::vec3 scale = posinfo[j]-&gt;transform3D.GetScale();
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(scale.x, 0.0f, 0.0f), glm::vec3(0.0f, -1, 0.0f)));
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(-scale.x, 0.0f, 0.0f), glm::vec3(0.0f, -1, 0.0f)));
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(0.0f, scale.y, 0.0f), glm::vec3(0.0f, 0.0f, 1)));
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(0.0f, -scale.y, 0.0f), glm::vec3(0.0f, 0.0f, -1)));
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(0.0f, 0.0f, scale.z), glm::vec3(0.0f, -1, 0.0f)));
            shadowTransforms.push_back(shadowProj * glm::lookAt(posinfo[j]-&gt;transform3D.GetPosition(), posinfo[j]-&gt;transform3D.GetPosition() + glm::vec3(0.0f, 0.0f, -scale.z), glm::vec3(0.0f, -1, 0.0f)));


            glViewport(0, 0, 1024, 1024);
            glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
            glClear(GL_DEPTH_BUFFER_BIT);
            shaderDepth.use();
            for (unsigned int i = 0; i &lt; 6; ++i)
                shaderDepth.setMat4("shadowMatrices[" + std::to_string(i) + "]", shadowTransforms[i]);
            shaderDepth.setFloat("far_plane", far_plane);
            shaderDepth.setVec3("lightPos", posinfo[j]-&gt;transform3D.GetPosition());

            for (int i = 0; i &lt; renderconp.size(); i++) {
                if (nullopt != renderconp[i]) {
                    glActiveTexture(GL_TEXTURE0);
                    glBindTexture(GL_TEXTURE_2D, renderconp[i]-&gt;model_-&gt;id_texture);
                    if (nullopt != posinfo[i]) {
                        renderconp[i]-&gt;model_-&gt;Render(shaderDepth, posinfo[i]-&gt;transform3D);
                    }

                }
            }

            glBindFramebuffer(GL_FRAMEBUFFER, 0);

            // reset viewport
            glViewport(0, 0, (GLsizei)widthScreen, (GLsizei)heightScreen);

            // 2. render scene as normal using the generated depth/shadow map  
            // --------------------------------------------------------------
            shader.use();
            shader.Tranformation(cam-&gt;cam_, camTr-&gt;transform3D, widthScreen, heightScreen);
            // set light uniforms
            if (nullopt != posinfo[j]) {
                shader.setVec3("light_use.lightPos", posinfo[j]-&gt;transform3D.GetPosition());
            }

            shader.setVec3("light_use.ambient", lightinfo[j]-&gt;Ambient);
            shader.setVec3("light_use.diffuse", lightinfo[j]-&gt;Diffuse);
            shader.setVec3("light_use.specular", lightinfo[j]-&gt;Specular);
            shader.setVec3("light_use.viewPos", lightinfo[j]-&gt;ViewPos);
            shader.setInt("light_use.type", lightinfo[j]-&gt;type);
            shader.setVec3("light_use.direction", lightinfo[j]-&gt;Direction);
            shader.setFloat("light_use.constant", lightinfo[j]-&gt;Constant);
            shader.setFloat("light_use.linear", lightinfo[j]-&gt;Linear);
            shader.setFloat("light_use.quadratic", lightinfo[j]-&gt;Quadratic);
            shader.setFloat("light_use.cutOff", lightinfo[j]-&gt;CutOff);
            shader.setFloat("light_use.outerCutOff", lightinfo[j]-&gt;OuterCutOff);
            shader.setFloat("far_plane", far_plane);

            for (int i = 0; i &lt; renderconp.size(); i++) {
                if (nullopt != renderconp[i]) {

                    glActiveTexture(GL_TEXTURE0);
                    glBindTexture(GL_TEXTURE_2D, renderconp[i]-&gt;model_-&gt;id_texture);
                    glActiveTexture(GL_TEXTURE2);
                    glBindTexture(GL_TEXTURE_CUBE_MAP, depthMap);

                    shader.setVec3("matirial_use.ambient", renderconp[i]-&gt;matirial_.Ambient);
                    shader.setVec3("matirial_use.diffuse", renderconp[i]-&gt;matirial_.Diffuse);
                    shader.setVec3("matirial_use.specular", renderconp[i]-&gt;matirial_.Specular);
                    shader.setFloat("matirial_use.shininess", renderconp[i]-&gt;matirial_.Shininess);

                    if (nullopt != posinfo[i]) {
                        renderconp[i]-&gt;model_-&gt;Render(shader, posinfo[i]-&gt;transform3D);
                        //renderconp[i]-&gt;model_-&gt;Draw(shader);
                    }
                }
            }

            glBlendFunc(GL_ONE, GL_ONE);
        }

    }

    glDisable(GL_BLEND);
}


int WinMain()
{
    float deltaTime = 0.0f;
    float lastFrame = 0.0f;

    bool* changeIntervalue = (bool*)malloc(sizeof(bool) * 4);

    RMPH::WindowSystem PD;
    RMPH::Window screen{ kWidthWindow,kHeightWindow,"PointShadowMap",&PD };

    RMPH::StartGlad();

    RMPH::Input inputManager{ &screen,&PD };

    RMPH::Shader ourShaderShadow("../deps/shaders/vertexShadow.vs", "../deps/shaders/fragmentShadow.fs", nullptr);
    //IMPORTANTE PONER LOS SHADERS QUE TOCA PARA EL SHADOW COMO ESTA EXPLICADO EN OTROS EJEMPLOS

    RMPH::ECSManager Manager;

    RMPH::RenderComponent avg, avgProto;

    size_t avgdemo = Manager.create_entity();
    size_t avgdemo2 = Manager.create_entity();
    size_t avgdemo3 = Manager.create_entity();
    size_t avgdemo4 = Manager.create_entity();
    size_t avgdemo5 = Manager.create_entity();
    size_t lightD = Manager.create_entity();
    size_t lightA = Manager.create_entity();
    size_t lightSNSE = Manager.create_entity();
    size_t lightSSE = Manager.create_entity();
    size_t lightP = Manager.create_entity();

    size_t cam = Manager.create_entity();

    Manager.add_component_type&lt;RMPH::RenderComponent&gt;();
    Manager.add_component_type&lt;RMPH::TranformComponent&gt;();
    Manager.add_component_type&lt;RMPH::LightComponent&gt;();
    Manager.add_component_type&lt;RMPH::CameraComponent&gt;();

    avgProto.model_ = std::make_shared&lt;RMPH::Model&gt;("../deps/obj/cube.obj");
    avgProto.matirial_.Ambient = glm::vec3(0.329412f, 0.223529f, 0.027451f);
    avgProto.matirial_.Diffuse = glm::vec3(0.780392f, 0.568627f, 0.113725f);
    avgProto.matirial_.Specular = glm::vec3(0.992157f, 0.941176f, 0.807843f);
    avgProto.matirial_.Shininess = 0.21794872f * 128.0f;

    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3) = avgProto;
    Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4) = avgProto;
    //Manager.get_component&lt;RMPH::RenderComponent&gt;(lightP) = avgProto;

    //stbi_set_flip_vertically_on_load(true);

    RMPH::TranformComponent  avg5, avg6, avg7, avg8, avg9, avg10, avgCam, avgLgh, avgLgh2, avgLgh3, avgLgh4, avgLgh5;

    //CUBE
    avg6.transform3D = RMPH::Transform3D(glm::vec3(4, 0, 0), glm::vec3(0.5f, 3, 3), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo) = avg6;

    avg5.transform3D = RMPH::Transform3D(glm::vec3(2, 0, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo2) = avg5;

    avg8.transform3D = RMPH::Transform3D(glm::vec3(0, 2, 0), glm::vec3(0.5f, 0.5f, 0.5f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo3) = avg8;

    avg9.transform3D = RMPH::Transform3D(glm::vec3(0, 4, 0), glm::vec3(3, 0.5f, 3), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo4) = avg9;

    avg10.transform3D = RMPH::Transform3D(glm::vec3(0, -2, 0), glm::vec3(9, 0.5f, 9), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(avgdemo5) = avg10;

    //CAMERA

    avgCam.transform3D = RMPH::Transform3D(glm::vec3(0, 10, -5), glm::vec3(1, 1, 1), glm::vec3(45, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(cam) = avgCam;

    //LIGHT

    avgLgh.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightA) = avgLgh; //ambient

    avgLgh2.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightD) = avgLgh2; //directional

    avgLgh4.transform3D = RMPH::Transform3D(glm::vec3(2, 2, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightSNSE) = avgLgh4; //spot NS

    avgLgh5.transform3D = RMPH::Transform3D(glm::vec3(-2, 2, 0), glm::vec3(0.2f, 0.2f, 0.2f), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightSSE) = avgLgh5; //spot s

    avgLgh5.transform3D = RMPH::Transform3D(glm::vec3(0, 0, 0), glm::vec3(1, 1, 1), glm::vec3(0, 0, 0));
    Manager.get_component&lt;RMPH::TranformComponent&gt;(lightP) = avgLgh3; //point

    RMPH::CameraComponent avgC;

    avgC.cam_ = std::make_shared&lt;RMPH::Camera&gt;(0.1f, 45.0f, 10.0f, 1, RMPH::Camera::View::Perspectiva);

    Manager.get_component&lt;RMPH::CameraComponent&gt;(cam) = avgC;

    RMPH::LightComponent avgLightD, avgLightA, avgLightSNSE, avgLightSSE, avgLightP;

    RMPH::Shader DepthCreater("../deps/shaders/vertexDepthMap.vs", "../deps/shaders/fragmentDepthMap.fs", nullptr); // Para sombras normales
    RMPH::Shader DepthCubeCreater("../deps/shaders/vertexPointDepthMap.vs", "../deps/shaders/fragmentPointDepthMap.fs", "../deps/shaders/geometryPointDepthMap.gs"); // Para Point shadow

    avgLightD.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightD.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightD.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightD.Specular = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightD.Direction = glm::vec3(1, 1, 1);
    avgLightD.Constant = 1.0f;
    avgLightD.Linear = 0.09f;
    avgLightD.Quadratic = 0.032f;
    avgLightD.CutOff = glm::cos(glm::radians(12.5f));
    avgLightD.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightD.type = RMPH::Directional;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightD) = avgLightD;

    avgLightA.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightA.Ambient = glm::vec3(0.3, 0.3, 0.3);
    avgLightA.type = RMPH::Ambient;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightA) = avgLightA;

    avgLightSNSE.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightSNSE.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightSNSE.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightSNSE.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLightSNSE.Direction = glm::vec3(0, -1, 0);
    avgLightSNSE.Constant = 1.0f;
    avgLightSNSE.Linear = 0.09f;
    avgLightSNSE.Quadratic = 0.032f;
    avgLightSNSE.CutOff = glm::cos(glm::radians(12.5f));
    avgLightSNSE.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightSNSE.type = RMPH::SpotNoSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightSNSE) = avgLightSNSE;

    avgLightSSE.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightSSE.Ambient = glm::vec3(0.6f, 0.6f, 0.2f);
    avgLightSSE.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightSSE.Specular = glm::vec3(1.0f, 1.0f, 1.0f);
    avgLightSSE.Direction = glm::vec3(0, -1, 0);
    avgLightSSE.Constant = 1.0f;
    avgLightSSE.Linear = 0.09f;
    avgLightSSE.Quadratic = 0.032f;
    avgLightSSE.CutOff = glm::cos(glm::radians(12.5f));
    avgLightSSE.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightSSE.type = RMPH::SpotSoftEdge;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightSSE) = avgLightSSE;

    avgLightP.ViewPos = Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetPosition();
    avgLightP.Ambient = glm::vec3(0.2f, 0.2f, 0.2f);
    avgLightP.Diffuse = glm::vec3(0.5f, 0.5f, 0.5f);
    avgLightP.Specular = glm::vec3(0, 0, 0);
    avgLightP.Direction = glm::vec3(1, 0, 0);
    avgLightP.Constant = 1.0f;
    avgLightP.Linear = 0.09f;
    avgLightP.Quadratic = 0.032f;
    avgLightP.CutOff = glm::cos(glm::radians(12.5f));
    avgLightP.OuterCutOff = glm::cos(glm::radians(17.5f));
    avgLightP.type = RMPH::Point;

    Manager.get_component&lt;RMPH::LightComponent&gt;(lightP) = avgLightP;

    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo2).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo3).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo4).value(), "../texture/cube.jpg");
    SetTexture(Manager.get_component&lt;RMPH::RenderComponent&gt;(avgdemo5).value(), "../texture/cube.jpg");

    // configure depth map FBO
       // -----------------------
    const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;
    unsigned int depthMapFBO;
    // create depth texture
    unsigned int depthMap;

    RMPH::CreateDepthBuffer(depthMapFBO, depthMap, SHADOW_WIDTH, SHADOW_HEIGHT); //Para sombras normales

    unsigned int depthCubeMapFBO;
    unsigned int depthCubemap;

    RMPH::CreateDepthBufferCubeMap(depthCubeMapFBO, depthCubemap, SHADOW_WIDTH, SHADOW_HEIGHT); //Para sombras point

    while (screen.IsOpen())
    {

        float currentFrame = static_cast&lt;float&gt;(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        //Manager.get_component&lt;RMPH::LightComponent&gt;(lightSSE)-&gt;Direction = glm::vec3(glm::vec3(sin(glfwGetTime()) * 3.0f, 5.0 + cos(glfwGetTime()) * 1.0f, cos(glfwGetTime()) * 2.0f)); // para mover la luz dirrecional

        if (inputManager.IsKeyPressed(RMPH::Input::MOUSE_LEFT)) {

            float xoffset = inputManager.MouseX() - kLastX;
            float yoffset = kLastY - inputManager.MouseY();

            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();

            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(yoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, xoffset * Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MouseSensitivity, 0));
        }
        else {
            kLastX = inputManager.MouseX();
            kLastY = inputManager.MouseY();
        }

        if (inputManager.IsKeyPressed(RMPH::Input::UP)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }

        if (inputManager.IsKeyPressed(RMPH::Input::DOWN)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetFront() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::LEFT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::RIGHT)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetRight() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::Q)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(-Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::E)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Translate(Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.GetUp() * (Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;MovementSpeed * deltaTime));
        }

        if (inputManager.IsKeyPressed(RMPH::Input::D)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, -Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::A)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(0, Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::W)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(-Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }
        if (inputManager.IsKeyPressed(RMPH::Input::S)) {
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam).value().transform3D.Rotate(glm::vec3(Manager.get_component&lt;RMPH::CameraComponent&gt;(cam).value().cam_-&gt;ViewSensitivity, 0, 0));
        }

        //Render diferente para las sombras

        RenderingShadow(Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), //Render de sombras
            ourShaderShadow, Manager.get_component_list&lt;RMPH::LightComponent&gt;(), Manager.get_component&lt;RMPH::CameraComponent&gt;(cam),
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam), depthMapFBO, depthMap, DepthCreater, kWidthWindow, kHeightWindow);

        RenderingPointShadow(Manager.get_component_list&lt;RMPH::RenderComponent&gt;(), Manager.get_component_list&lt;RMPH::TranformComponent&gt;(), //Render de sombras point
            ourShaderShadow, Manager.get_component_list&lt;RMPH::LightComponent&gt;(), Manager.get_component&lt;RMPH::CameraComponent&gt;(cam),
            Manager.get_component&lt;RMPH::TranformComponent&gt;(cam), depthCubeMapFBO, depthCubemap, DepthCubeCreater,
            kWidthWindow, kHeightWindow);

        screen.SwapBuffer();
        glfwPollEvents();
    }

    screen.~Window();
    PD.~WindowSystem();
    inputManager.~Input();

    return 0;
}
                </code></pre>
            </div>
        </div>
    </div>

    <!-- Documentation -->
    <div class="w3-container" id="Documentation" style="margin-top:25px">
        <h1 class="w3-xxxlarge w3-text-red"><b>Documentation</b></h1>
        <hr style="width:50px;border:5px solid red" class="w3-round">
        <p>If you have any doubt about the engine and the library you can consult the official documentation here.</p>
        <a href="https://goldsolacepvg.github.io/FatalEngineDocumentation/" target="_blank" title="Fatal Engine Documentation C++">
            <img src="/res/img/DocLogo.jpg" class="doc_logo" width="250px" height="auto">
        </a>
        <a href="" target="_blank" title="Fatal Engine Documentation Lua (Soon)">
            <img src="/res/img/DocLogo.jpg" class="doc_logo_lua" width="250px" height="auto">
        </a>
        <div class="container">
            <h5 style="margin-left: 135px;">C++ Documentation</h5>
            <h5 style="margin-left: 125px;">Lua Documentation (Soon)</h5>
        </div>
    </div>
    


    <!-- End page content -->
    </div>

    <div class="w3-light-grey w3-container w3-padding-32" style="margin-top:75px;padding-right:58px"><p class="w3-right">Made by <a title="Fatal Team" target="_blank" class="w3-hover-opacity">Fatal Team</a></p></div>

    <script src="./res/js/main.js"></script>

</body>
</html>
